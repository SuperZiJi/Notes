分片内部原理：
问题：
1.为什么搜索是 近 实时的？
2.为什么文档的 CRUD (创建-读取-更新-删除) 操作是 实时 的?
3.Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据?
4.为什么删除文档不会立刻释放空间？
5.refresh, flush, 和 optimize API 都做了什么, 你什么情况下应该是用他们？ 


1.副本：每个主分片都有一个副本分片，并且他们是在不同的节点上，因为在同一个节点上同时保存主分片和副本分片是没有意义的，当节点丢失（硬件故障），我们也将失去这个节点的所有副本数据

2.主分片不可变，但是可以增加副本分片，因为查询操作是可以发生在副本分片的

3.主分片和副本分片均匀分布在多个节点上，新增一个节点，会重新分配

4.关闭一个主节点，第一件事就是重新选择一个主节点，把被关掉的主分片的副本分片提升为主分片

5.ec最重要的就是保证文本可以被搜索，ec使用倒排索引，每个字段都有自己的倒排索引
	倒排索引被写入磁盘后是不可改变的，永远不会改变。
	价值：
		1.不需要锁，如果你从来不更新索引，就不用担心多进程同时修改数据的问题
		2.索引被读入内核的文件系统缓存后，就会留存在那里。只要文件系统缓存中还有足够的空间，那么大部分读请
			求，都是直接请求内存，而不是命中磁盘。
		3.其它缓存，在索引的生命周期始终有效。他们不需要在每次变更数据时被重建。
		4.大的倒排索引，允许数据被压缩。

6.保留不变性的前提下实现倒排索引的更新：使用更多的索引
	通过增加新的补充索引来反映新近的修改，而不是重写整个倒排索引。每一个倒排索引都会被轮流查询，从最早---最新
	查询完，对结果进行合并 
	
7.分片（shard）：一个Lucene索引

8.索引：分片的集合



一，文档要被搜索到，所以有倒排索引，倒排索引是不可变的，为了更改，会追加新的倒排索引，保证新的文档可以被搜索到
二，es搜索是近实时性的，新的文档一秒内可以被搜索到。新的索引会先进入，索引内存缓冲区，每一秒refresh到文件系统缓存
三，此时新的段并没有提交，没有写入磁盘，但是lucene保证即使段未提交，也可以写入和打开，所以可以被搜索到，比提交代价小
四，TransLog保证不丢失文件，写入内存缓冲区的同时会写TransLog，当refresh时，内存缓冲区的内容被清空，但是Log不清空，TransLog每五秒写入磁盘

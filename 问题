１、@RefreshScope注解
２、自定义异常处理器
３、当当sharding
４、redis配置
５、redis 二进制安全是什么？
	不关心字符串格式，不会用某种特殊格式来读取字符串，而是严格按照二进制
６、redis持久化
	RDB:设定一个时间点进行数据持久化，大规模数据持久化，数据完整性敏感的时候不建议。
		会创建一个子进程fork，不影响主进程新能。
	AOF:持久化指令，默认每秒持久化一次，如果遇到故障，只丢失一秒的数据，如果遇到磁盘空间满等问题，可以使用
		redis-check-aof进行日志修复
		引入了重写机制，如100条incr会压缩成一个set指令。重写时，创建一个fork子进程，fork读取原aof文件
		同时，重写一个新的文件，这时新的指令过来，会进入缓冲区，同时写入原aof文件，当新文件重写完毕，通知
		主进程。
７、redis主从
	slave会向master发送sync指令，主服务器收到之后会启动一个子进程进行RDB,同时，新的指令缓存在内存
	当RDB结束后，会把文件发送给slave，slave接收后存储，然后读取到内存。然后，master会把缓存指令用redis
	协议传送给slave

８、redis事务处理
	MULTI：组装一个事务，MULTI后，每一个命令都会进入内存队列中缓存起来
	EXEC：执行一个事务，执行时，所有被QUEUED的命令都会被组装成一个事务执行
		如果某个命令无法成功写入缓存队列，那么EXEC会错误
		如果执行过程中，某些命令是应用级错误，则redis会忽略，并执行其它的命令	
	DISCARD：取消一个事务
	WATCH：监视key，一旦这些key在事务执行之前被改变，则取消事务
		可以实现乐观锁（CAS）,可以监视多个key

９、StringRedisSerializer

１０、使用redisTmplate　封装一个便捷的redis工具

１１、java序列化和反序列化
	http://www.importnew.com/24490.html
		

１２、封装一个RedisLock工具类

１３、Redis数据类型 
	string 字符串 
	list 列表，常用来做队列，最大长度２^32-1，用双向链表实现，支持反向查找和遍历　场景：缓冲队列
	set 集合，不可重复，无序，用一个value永远为null的HashMap实现　场景：存储列表，需要不重复
	sortedSet　有序集合，使用HashMap和跳跃表SkipList来保证数据的存储和有序　场景：存储列表，不重复，且有序
	hash 哈希　场景：存储用户信息
	hyperLogLog　基数统计（不重复元素的个数）

１４、sortedSet实现原理

１５、计算机内存模型
	cpu和内存之间速度差，因此有了高速缓存，指令运行时会在高速缓存，执行完毕再刷新回内存
	高并发下会造成缓存一致性问题：
		硬件：
			总线lock：会阻塞cpu对其它部件的访问，只有一个cpu可以操作这个变量
			缓存一致性协议：intel的mesi协议：核心思想：当cpu写数据时，如果发现变量是共享变量，会发出
				信号，让其它cpu把该变量的缓存变为无效状态，其它cpu需要读取这个变量，从内存重新读取

１６、并发的三个概念
	原子性：要么全部成功，要么全部失败
	可见性：对于共享变量，Ａ线程修改了值，其它线程可以立即看到修改的值
	有序性：程序执行顺序不一定是按照代码顺序，因为会发生指令重排，cpu为了提高程序的运行效率，但是它会保证结果相
		同。cpu重排过程中会考虑指令的数据依赖性　如Ａ依赖Ｂ 则B一定在Ａ之前
		但是多线程会造成问题。比如线程A的指令重排，导致线程Ｂ使用的变量还未初始化。
	因此想要并发的程序无误的执行，必须同时保证以上三个特性。

１７、java内存模型提供的高并发机制
	jvm试图定义一种java内存模型JMM来屏蔽硬件和操作系统之间的差异。jvm没有屏蔽指令重排和高速缓存，所以会存在可见
	性问题和有序性问题。

	java语言对于原子性、可见性、有序性提供了哪些保障？
	答：
		对于原子性：只保证简单的赋值是原子操作
		对于可见性：java提供volatile关键字来保证，当一个共享变量被volatile关键字来修饰的时候，它会保证被修
			改的值立刻被更新到主存。而普通变量不知道什么时候会被更新到主存。
			也可以用synchronized和Ｌock来保证可见性。
		对于有序性：可以使用volatile和synchronized和lock来保证有序性
			JMM先天有序性：happens-before原则（先行发生原则）：
				程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先发生。
				锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作
				volatile变量规则：变量的写操作先行于读操作
				传递规则：ａ在ｂ之前，ｂ在c之前，那么a在c之前
				线程启动规则：Thread对象的start()方法先行于此线程的每一个动作
				线程中断规则：interrupt()方法先行于代码检测到中断事件的发生。（检测中断，已经调用interrupt()方法）
				线程终结规则：线程所有操作都在终止检测之前。join()、isAlive()检测线程已经终止
				对象终结规则：对象的初始化工作先行于finalize（）方法。

１８、volatile关键字保证可见性和有序性
	可见性：用volatile修饰的变量，可以保证在A线程更改了值之后，其它线程缓存中的值立即无效，重新从主存读取，从而
		保证立刻生效，保证可见性。
	有序性：可以在一定程度上保证有序性，使用volatile进行禁止指令重排有两层意思
		1.当程序执行到volatile修饰的变量时，保证前面的操作已经执行，结果对后面的操作可见，后面的操作肯定还没执行。
		2.在进行指令优化时，不能将在volatile变量访问的语句放到后面执行，也不能把volatile变量后面的语句放到其前面执行。
		举例：x=1; y=0; flag=true;　x=3; y=1;　　flag是volatile修饰，则保证前两句不会重排到它后面，后两句不会重排到它前面。并且前两句一定执行完毕
	无法保证原子性：volatile是通过store和load指令来保证可见性的，在写的时候会直接更新到主存，在读的时候直接读取主存。但是如i++操作，包含读，修改，写入主存三个操作，是无法保证原子性的。A线程读取10后阻塞，B线程读取10后修改为11，Ａ恢复运行，修改为11，所以造成了不是原子性。

１９、https://www.cnblogs.com/dolphin0520/p/3920373.html

２０、tcp三次握手（建立连接）
	１、客户端请求服务器，SYN=1,并且随机生成一个seq=j
	２、服务器返回客户端，SYN=1,ACK=1,ack=j+1,并且随机生成一个seq=k
	３、客户端请求服务器，确认连接,校验ack是否为j+1，校验通过ACK=1,ack=k+1发送给服务器，服务器检查ack=k+1
	
	长期收不到返回，会再次发包请求
	
	SYN攻击：服务器返回客户端后，处于SYN_RCVD状态，等待返回，攻击者伪造随机ip请求建立连接，但是无法给予返回，造
	成正常连接无法加入队列而被丢弃，从而引起网络阻塞系统瘫痪。
	

２１、tcp四次挥手(终止连接)
	一方主动发起终止连接请求，只代表它不会再发送数据，但是还可以继续接收数据，因此需要双方都关闭才关闭，所以一共是四次
	1.client发送FIN m
	2.server返回ack=m+1
	3.server发送FIN k
	4.client返回ack=k+1
	
２１、单工、半双工、全双工
	单工：只支持数据单方向传输
	半双工：支持数据双向传输，但是同一时刻只能一个方向
	全双工：可以同时进行双向传输

２２、串行和并行
	串行：单条线路，效率低，抗干扰能力强，适合长距离
	并行：多条线路，效率高，抗干扰能力差，适合短距离	

２３、同步、异步和阻塞、非阻塞
	同步阻塞：程序等待响应，并且不可去做其它事情
	同步非阻塞：程序每隔一段时间取查询是否响应，其它时间可以做其他事
	异步非阻塞：程序发送请求后去做其他事，响应什么时候发送过来都可以接收。
	异步阻塞：（太蠢了）可以理解为，程序阻塞，监听也在监听

２４、分布式锁
	基于数据库：插入一条数据主键做约束，保证并发问题
	基于缓存：利用redis原子性
	基于zookeeper：

２５、结构化搜索

２６、redis是线程安全的，单线程

２７、什么是url_safe
	base64将二进制转码成可见字符串，方便Http传输,但是base64转码会生成 + / = 这种被URL进行转码的特殊字符串，导
	致数据不一致。所以在发送前，将这几个符号替换成不会被转码的字符，收到数据后再替换回去

28.I/O多路复用 select poll epoll  http://blog.jobbole.com/100079/   https://www.zhihu.com/question/32163005
	select:监听多个Io,某个I

29.org.testNg

30.spring aop
	aspect:切面，对横切关注点的抽象，（我们要添加的操作）
	joinpoint:连接点，被拦截到的点（在spring中就是被拦截到的方法）
	pointCut:切入点
	目标对象：代理的目标对象
	weave：将切面应用到目标对象，并创建代理对象的过程
	advice:
		通知类型：
			@Before：前置通知
			@After：后置通知：无论是否发生异常，都执行
			@AfterReturning:返回通知：正常结束才执行
			@AfterThrowing:异常通知：程序异常执行
			@Around:环绕通知：可以自定义
31.mysql 行锁
	innoDB引擎支持：表锁、行锁
	行锁：排它锁（写锁）for update
		共享锁（读锁）lock in share mode
	注意：必须走索引才是行锁
	select for update 行锁
	insert update delete默认加排它锁
32.mysql 表锁
	表共享锁（Read Lock）
	表独占锁（Write Lock）
	表锁和读锁是互斥的，不可同时读写

33.为什么多线程    多线程造成的并发问题的原因是什么  如何解决并发问题	
